# 경계

개발을 진행하다 보면 외부 패키지, 오픈소스, 사내 인터페이스 등 구성하려는 서비스에서 외부 코드를 사용하는 경우가 잦다

## 제공자와 사용자

패키지, 프레임워크 제공자는 적용성을 최대한 넓히려고 한다.

사용자는 자신의 요구에 집중하는 인터페이스를 원한다.

그 예시로 java.util.Map이 있다.


<pre><code>
<1> Map 그대로 사용
Map senseors = new HashMap();
Sensor s = (Sensor)sensors.get(sensorId);

<2> Generics 사용
Map<String, Sensor> sensors = new HashMap<Sensor>();
Sensor s = sensors.get(sensorId);

<3> Class 사용
public class Sensors {
    private Map sensors = new HashMap();

    public Sensor getById(String id) {
        return (Sensor) sensors.get(id);
    }
}
</code></pre>


- **<1> :** Map이 반환하는 Object의 변환 책임이 클라이언트에게 있다. 또한, 깨끗한 코드로 보기 어렵고 코드의 의도가 드러나지 않는다.
- **<2> :** Generics를 통해 가독성을 높이지만 Map 인터페이스가 변할 경우 수정할 코드가 상당히 많아진다.
- **<3> :** 클래스를 통한 캡슐화를 통해 객체 유형을 관리하고 변환한다.


<3>의 코드가 책에서 제공하는 Clean Code로 경계 인터페이스인 Map을 Sensors 안으로 숨기고 Map 인터페이스가 변해도 나머지 프로그램에 영향을 끼치지 않는다. 또한, 필요한 인터페이스를 제공하여 설계 규칙과 비즈니스 규칙을 따르도록 강제할 수 있다.

실제 예시로 **log4j**가 책에서 정리해준 예시이다. p148를 보면서 확인하면 좋을 것 같다.

## 경계 살피고 익히기

인터페이스 사용자 입장에서 외부 패키지의 실수는 우리의 잘못이 아니지만 사용할 코드를 테스트하는 것이 바람직하다.

### 학습 테스트
짐 뉴커그는 우리쪽 코드를 작성해 외부 코드를 호출하는 대신 먼저 간단한 테스트 케이스를 작성해 외부 코드를 익히도록 권장한다.

이러한 것을 **학습 테스트**라고 지칭하며 API를 사용하려는 목적에 초점을 맞춘다.

이러한 학습 테스트는 투자하려는 노력보다 얻는 성과가 크다.

패키지의 경우 새 버전이 나올 때마다 새로운 위험이 생기기 마련인데 학습 테스트를 통한 테스트 케이스 구성은 추후 패키지의 새 버전이 나올 때마다 발생가능한 위험을 방지할 수 있다.

## 인터페이스의 정의

아는 코드와 모르는 코드를 분리하여 경계를 두어야 한다. 이러한 경계 너머에는 지식의 영향이 미치지 못하는 코드 영역이 존재할 수 있다.

![Alt text](image.png)

위의 그림과 같이 모르는 코드를 사용하기 위한 인터페이스를 구현하면 다음의 장점이 존재한다.

- 코드 가독성 향상
- 코드 의도 분명
- 인터페이스의 통제권 : 모르는 코드를 사용하는 입장에서 통제의 어려움이 존재하는데 인터페이스를 정의하여 통제권을 가져온다.

또한, **Adapter Pattern**을 통해 외부 코드의 사용을 캡슐화해 변경에 있어서 수정할 코드를 한곳으로 모으기도 한다.

## 깨끗한 경계

경계에서는 주로 변경이 자주 일어난다. 이러한 변경이 일어나면 외부 코드를 이용하는 클라이언트는 코드를 수정해야하는 불편함이 존재한다.

이를 방지하기 위해서 책에서는 **소프트웨어 설계**를 강조한다.

설계를 우수하게 한다면 많은 투자와 재작업이 필요없어 진다. 하지만 반대의 경우 엄청난 시간과 노력을 통해 재작업의 과정을 거쳐야하고 그중 통제하지 못하는 코드가 존재하여 버릴 수 밖에 없는 소프트웨어가 될 수도 있다.