# 단위 테스트

💡 테스트 코드는 실제 코드 이상으로 중요하다. **유연성, 유지보수성, 재사용성**을 보존하고 강화하는 역할을 수행하기 때문이다.


### 1. TDD 법칙 세 가지

```jsx
1. 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다.
2. 컴파일은 실패하지 않으면서, 실행이 실패하는 정도로만 단위 테스트를 작성한다.
3. 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.
```

이렇게 업무를 진행할 경우, 하루에도 엄청난 수의 테스트 케이스가 만들어진다. 하지만, 방대한 테스트 코드는 관리가 어렵다는 단점도 존재한다.

### 2. 깨끗한 테스트 코드 유지하기

<aside>
💡 테스트는 유연성, 유지보수성, 재사용성을 제공한다.

</aside>

- “Diry & Fast”
    - 변수 이름에 신경쓰지 않음.
    - 테스트 함수는 간결하거나 비서술적
    - 테스트 코드는 돌아가기만 하면 됨 (뜨끔)

`지저분하고 형식적인 테스트 코드를 작성하느니, 테스트를 안하는 것이 더 낫다.`

실제 코드가 변하면, 테스트 코드도 그에 따라 변해야 한다. 이런 유지 보수 비용으로 인해 테스트 슈트(테스트 유닛의 묶음)를 폐기하게 되는 경우, 결함율은 높아지고 코드는 엉망이된다.



- 코드에 유연성, 유지 보수성, 재사용성을 제공하는 버팀목이 `“단위 테스트”`

실제 코드를 점검하는 자동화된 단위 테스트는 설계와 아키텍쳐를 최대한 깨끗하게 보존하는 열쇠이다.

테스트 케이스가 있다면, 설계가 엉망이더라도 큰 문제 없이 코드와 아키텍처 및 설계를 모두 개선할 수 있다.

### 3. 깨끗한 테스트 코드

깨끗한 테스트 코드를 만드는 핵심 키는 “가독성”

이 가독성을 위해서 최소의 표현으로 많은 것을 나타낼 수 있도록

`명료성`, `단순성`, `풍부한 표현력` 이 필요하다.

```jsx

1) 테스트 자료를 만든다(mock data)
2) 테스트 자료를 조작한다. 
3) 조작한 결과가 올바른지 확인한다.
```

테스트와 무관한 코드를 모두 제거해 진짜로 필요한 자료 유형과 함수만 사용해야 한다. 이 결과 코드를 읽는 사람은 코드가 수행하는 기능을 빨리 이해할 수 있게 된다.

- 도메인에 특화된 테스트 언어
    - 흔히 사용하는 API 대신, API 위에 함수와 유틸리티를 구현하여 사용하기 때문에 테스트 코드 작성이 쉬워진다.
    - 이런 테스트 API는 처음부터 설계된 것이 아니라 리팩토링을 거쳐서 만들어진다.
- 이중 표준
    - 단순하고 간결하면서도 표현력을 갖추고 있어야 하지만, **실제 코드만큼 효율적일 필요는 없다.**

### 4. 테스트 함수 마다 한 개념만 테스트하라.

독자적인 개념은 개념마다 테스트 함수를 만드는 것이 바람직하다. 여러 개념을 한 함수로 몰아넣으면 각 절의 존재 이유와 각 절이 테스트하는 개념을 모두 이해해야 하기 때문이다.

- `테스트 함수 하나는 개념 하나만 테스트 하자.`

### 5. F.I.R.S.T

- Fast(빠르게)

  **테스트는 빨라야 한다.** 테스트가 느리면 자주 실행하지 못 하고, 초반에 문제를 찾아내기 어렵기 때문에 코드 품질이 망가지게 된다.

- Independent(독립적으로)

  각 테스트는 서로 의존하면 안된다. 마찬가지로, 한 테스트가 다음 테스트를 실행할 환경을 준비해서도 안된다.

  테스트가 의존 관계에 놓일 경우, 연달아 실패할 때 원인을 진단하기 어려워진다. 이러한 부분은 결함을 늘린다.

- Repeatable(반복가능하게)

  **테스트는 빨라야 한다.** 테스트가 느리면 자주 실행하지 못 하고, 초반에 문제를 찾아내기 어렵기 때문에 코드 품질이 망가지게 된다.

- Self - Validating(자가 검증)

  **테스트는 boolean 값으로 결과를 내야 한다.** 성공 아니면 실패, 두 가지의 결과만 나타나야 한다. 테스트 결과를 알기 위해 로그를 보거나 텍스트 파일 두 개를 비교하는 등 수작업이 필요하다면 판단은 주관적으로 변하게 된다.

- Timely (적시에)

  테스트는 적시에 작성해야 한다. 단위 테스트는 테스트하려는 실제 코드를 구현하기 직전에 구현한다.

  실제 코드를 구현한 다음에 테스트 코드를 만들면 실제 코드가 테스트하기 어렵다는 사실을 발견할지도 모른다.
