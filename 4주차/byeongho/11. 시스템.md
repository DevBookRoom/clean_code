# 시스템

> 복잡성은 죽음이다. 개발자에게서 생기를 앗아가며, 제품을 계획하고 제작하고 테스트하기 어렵게 만든다. - 레이 오지

해당 부분에서는 소프트웨어 시스템의 복잡성의 문제를 논하지만 불가피하다고 한다. 그렇기에 이를 대비하기 위한 개발자들의 스킬들을 설명한다.

## 제작과 사용을 분리하자!
제작과 사용은 엄밀히 다른 과정이다. 그렇기에 우리는 소프트웨어 시스템을 개발에 준비과정(객체 생성, 의존성 연결)과 런타임 로직을 분리해야한다.

이를 분리하지 않은 예시 코드는 다음과 같다.

<pre><code>
public Service getService(){
  if (service == null)
    service = new MyServiceImpl(...); // 모든 상황에 적합한 기본값일까?
   return service;
}
</code></pre>

Lazy Initialization/Evaluation (초기화/계산 지연)이라 불리는 코드의 형태이다.

**장점**
- 필요할 때까지 객체 생성을 미루어 불필요한 부하를 방지한다.
- null pointer를 반환하지 않는다.

**단점**
- 예시코드 기준 MyServiceImpl 생성자 인수에 명시적으로 의존
- MyServiceImpl이 무거운 객체인 경우 테스트를 위한 객체 (Mock Object/Test Double)을 생성해야 한다.


해당하는 기법은 한 번정도 사용하는 것은 큰 문제가 아니나 많은 애플리케이션에서 사용하고 이는 모듈성 저조와 중복의 문제를 발생시킨다.

우리는 ClecnCode를 통한 체계적이고 탄탄한 시스템을 만드는 개발자가 되어야 하기에 모듈성을 깨는 행휘는 지양해야한다.


책에서는 설정 논리와 일반 실행 논리를 분리하여 모듈성을 높여야하고 이를 위한 다음의 방식들을 선보인다.

### Main 분리

시스템 생성과 사용을 분리하는 방법 중 하나로 생성과 관련된 코드는 모두 main을 호출하는 모듈로 옮긴다. 나머지 애플리케이셔느, 시스템들은 모든 객체가 생성되었고 모든 의존성이 연결되었다고 가정하고 이를 사용한다.

해당 과정에서 애플리케이션은 main이나 객체가 생성되는 과정을 전혀 모른다.

### 팩토리

> 객체가 생성되는 시점을 애플리케이션단에서 제어하기 위해 사용한다.

main에서 factory 객체를 만들어서 전달한다. 자세한 구현을 숨기기위해 주로 Abstract Factory 패턴을 사용한다. 


애플리케이션은 전닳받은 factory만 사용하기에 생성하는 시점은 결정하지만 해당 코드에 대해서는 알지 못한다.

### 의존성 주입

제어역전 (IoC) 기법을 의존성 관리에 적용한 메커니즘으로 사용과 제적을 분리하는 강력한 수단이다.

IoC를 통해 한 객체가 맡은 보조 책임을 새로운 객체에게 전적으로 넘기고 새로운 객체는 넘겨받은 책임만 맡기에 SRP를 지키게 된다.

## 확장

> 처음부터 올바르게 시스템을 만들 수 있다는 믿음은 미신이다.

실젝 개발을 하다보면 이렇나 경우가 허다할 것이다. 하지만 이를 대비하는 것은 미래를 대비한 설계가 아닌 TDD와 CleanCode를 통한 확장의 용이성이 핵심이라고 책에서 주장한다.

### 횡단 관심사

영속성, 보안, 트랜잭션과 같이 애플리케이션 객체의 경계를 넘나들어 존재하는 코드들은 원론적으로 모듈화되고 캡슐화될 수 있다. 이를 횡돤 관심사라고 한다.

### AOP
횡돤 관심사에 대처해 모듈성을 확보하는 일반적인 방법론이다.

AOP에서는 관점(Aspect)라는 모듈 구성 개념을 "특정 관심사를 지원하려면 시스템에서 특정 지점들이 동작하는 방식을 일관성 있게 바꿔야 한다"라고 한다.

## 자바 프록시

단순한 상황에 적합한 것으로 개별 객체나 클래스에서 메서드 호출을 감싸는 좋은 경우이다.

다음의 예시들이 존재한다.
- JDK Dynamic Proxy : 인터페이스만 지원
- CGLIB, ASM, Javassist : 바이트 코드 처리 라이브러리로 클래스 프록시 사용 가능

## 순수 자바 AOP 프레임워크

스프링, JBoss AOP와 같은 여러 자바 프레임워크는 내부적으로 프록시를 사용한다.

특히, 대표적인 프레임워크인 스프링은 비즈니스 논리를 POJO로 구현하여 테스트를 개념적으로 더 쉽고 간단하게 제공한다.

## AspectJ 관점

AspectJ는 언어 차원에서 관점을 모듈화 구성으로 지원하는 자바 언어 확장이다. 해당하는 거승 관심사를 관점으로 분리하는 가장 강력항ㄴ 도구이다.

이를 사용하기 위해서 새언어 문법/사용법을 익혀야한다는 단점이 있었딪만 스프링에서 @AspectJ를 통해 관점이라는 개념을 쉽게 사용하도록 제공해 준디ㅏ.

## 테스트 주도 시스템 아키텍처 구축

관점으로 관심사를 분리 즉, 코드 수준에서 아키텍처 관심사를 분리하면 진정한 테스트 주도 아키텍처 구축이 가능해진다. 소프트웨어 구조의 경우 관점을 효과적으로 분리하면 극적인 변화가 가능하다 다시 말해 `아주 단순하면서도 멋지게 분리된 아키텍처`를 통해 프로젝트 결과물을 빠르게 출시한 후, 기반 구조를 추가하여 확장해나가야 한다.

책에서 언급하는 최선의 시스템 구조는 다음과 같다.
> POJO 객체로 구현되는 모듈화된 도메인으로 구성된다. 서로 다른 영역은 해당 영역 코드에 최소한의 영향을 미치는 관점이나 유사한 도구를 통해 통합한다.

## 의사 결정의 최적화

> 가능항 마지막 순간까지 결정을 미루어라.

위의 과정에서 관심사를 잘 분리하여 모듈을 생성한 시스템은 기민함을 제공합니다. 이러한 기민함은 최신 정보에 기반해 최선의 시점에 최적의 결정을 내리기가 쉬워지고 결정의 복잡성 또한 줄인다.


## 표준의 현명한 활용

과장되게 포장된 표준에 집착하는 경우 곡객 가치가 뒷전으로 밀려날 수 있다. 즉, 이러한 표준에 너무 집착하지 말고 표준을 제정한 목적을 떠올릴 수 있어야 한다.

## 도메인 특화 언어의 필요성

DSL는 간단한 스크립트 언어나 표준 언어로 구현한 API로 이를 이용해 짠 최적의 코드는 도메인 전문가가 작성한 구조적인 산문처럼 읽혀 도메인 개념과 구현 코드 사이에 존재하는 `의사소통 간극`을 줄이는데 도움을 준다.